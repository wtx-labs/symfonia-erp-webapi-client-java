/*
 * Symfonia WebAPI
 * Symfonia WebAPI - specyfikacja wybranych endpointow API systemu ERP Symfonia. Modele danych sa uproszczone i ograniczone do niektorych parametrow (wersja rozwojowa).
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package pl.wtx.symfonia.api.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import pl.wtx.symfonia.api.client.model.OrderIssueContractor;
import pl.wtx.symfonia.api.client.model.OrderIssuePosition;
import pl.wtx.symfonia.api.client.model.PaymentRegistry;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import pl.wtx.symfonia.api.client.invoker.JSON;

/**
 * OrderIssue
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.15.0")
public class OrderIssue {
  public static final String SERIALIZED_NAME_TYPE_CODE = "TypeCode";
  @SerializedName(SERIALIZED_NAME_TYPE_CODE)
  @javax.annotation.Nullable
  private String typeCode;

  public static final String SERIALIZED_NAME_SERIES = "Series";
  @SerializedName(SERIALIZED_NAME_SERIES)
  @javax.annotation.Nullable
  private String series;

  public static final String SERIALIZED_NAME_DEPARTMENT = "Department";
  @SerializedName(SERIALIZED_NAME_DEPARTMENT)
  @javax.annotation.Nullable
  private String department;

  public static final String SERIALIZED_NAME_PAYMENT_REGISTRY = "PaymentRegistry";
  @SerializedName(SERIALIZED_NAME_PAYMENT_REGISTRY)
  @javax.annotation.Nullable
  private PaymentRegistry paymentRegistry;

  public static final String SERIALIZED_NAME_PAYMENT_FORM_ID = "PaymentFormId";
  @SerializedName(SERIALIZED_NAME_PAYMENT_FORM_ID)
  @javax.annotation.Nullable
  private Integer paymentFormId;

  public static final String SERIALIZED_NAME_BUYER = "Buyer";
  @SerializedName(SERIALIZED_NAME_BUYER)
  @javax.annotation.Nullable
  private OrderIssueContractor buyer;

  public static final String SERIALIZED_NAME_RECIPIENT = "Recipient";
  @SerializedName(SERIALIZED_NAME_RECIPIENT)
  @javax.annotation.Nullable
  private OrderIssueContractor recipient;

  public static final String SERIALIZED_NAME_PRICE_KIND = "PriceKind";
  @SerializedName(SERIALIZED_NAME_PRICE_KIND)
  @javax.annotation.Nullable
  private Integer priceKind;

  public static final String SERIALIZED_NAME_SALE_PRICE_TYPE = "SalePriceType";
  @SerializedName(SERIALIZED_NAME_SALE_PRICE_TYPE)
  @javax.annotation.Nullable
  private Integer salePriceType;

  public static final String SERIALIZED_NAME_DESCRIPTION = "Description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  @javax.annotation.Nullable
  private String description;

  public static final String SERIALIZED_NAME_POSITIONS = "Positions";
  @SerializedName(SERIALIZED_NAME_POSITIONS)
  @javax.annotation.Nullable
  private List<OrderIssuePosition> positions = new ArrayList<>();

  public OrderIssue() {
  }

  public OrderIssue typeCode(@javax.annotation.Nullable String typeCode) {
    this.typeCode = typeCode;
    return this;
  }

  /**
   * Kod typu dokumentu. Odpowiednik pola [typDk] z importu specjalnego. Pole jest wymagane.
   * @return typeCode
   */
  @javax.annotation.Nullable
  public String getTypeCode() {
    return typeCode;
  }

  public void setTypeCode(@javax.annotation.Nullable String typeCode) {
    this.typeCode = typeCode;
  }


  public OrderIssue series(@javax.annotation.Nullable String series) {
    this.series = series;
    return this;
  }

  /**
   * Seria dokumentu. Odpowiednik pola [seria] z importu specjalnego. Pole jest wymagane.
   * @return series
   */
  @javax.annotation.Nullable
  public String getSeries() {
    return series;
  }

  public void setSeries(@javax.annotation.Nullable String series) {
    this.series = series;
  }


  public OrderIssue department(@javax.annotation.Nullable String department) {
    this.department = department;
    return this;
  }

  /**
   * Dzial, w ktorym ma zostac wystawiony dokument. Odpowiednik pola [dzial] z importu specjalnego. Pole jest wymagane.
   * @return department
   */
  @javax.annotation.Nullable
  public String getDepartment() {
    return department;
  }

  public void setDepartment(@javax.annotation.Nullable String department) {
    this.department = department;
  }


  public OrderIssue paymentRegistry(@javax.annotation.Nullable PaymentRegistry paymentRegistry) {
    this.paymentRegistry = paymentRegistry;
    return this;
  }

  /**
   * Get paymentRegistry
   * @return paymentRegistry
   */
  @javax.annotation.Nullable
  public PaymentRegistry getPaymentRegistry() {
    return paymentRegistry;
  }

  public void setPaymentRegistry(@javax.annotation.Nullable PaymentRegistry paymentRegistry) {
    this.paymentRegistry = paymentRegistry;
  }


  public OrderIssue paymentFormId(@javax.annotation.Nullable Integer paymentFormId) {
    this.paymentFormId = paymentFormId;
    return this;
  }

  /**
   * Id formy platnosci wykorzystywane do pobrania formy platnosci i uzupelnienia pol [nazwa] oraz [termin] z sekcji [formaPl] w imporcie specjalnym. Pole jest wymagane.
   * @return paymentFormId
   */
  @javax.annotation.Nullable
  public Integer getPaymentFormId() {
    return paymentFormId;
  }

  public void setPaymentFormId(@javax.annotation.Nullable Integer paymentFormId) {
    this.paymentFormId = paymentFormId;
  }


  public OrderIssue buyer(@javax.annotation.Nullable OrderIssueContractor buyer) {
    this.buyer = buyer;
    return this;
  }

  /**
   * Get buyer
   * @return buyer
   */
  @javax.annotation.Nullable
  public OrderIssueContractor getBuyer() {
    return buyer;
  }

  public void setBuyer(@javax.annotation.Nullable OrderIssueContractor buyer) {
    this.buyer = buyer;
  }


  public OrderIssue recipient(@javax.annotation.Nullable OrderIssueContractor recipient) {
    this.recipient = recipient;
    return this;
  }

  /**
   * Get recipient
   * @return recipient
   */
  @javax.annotation.Nullable
  public OrderIssueContractor getRecipient() {
    return recipient;
  }

  public void setRecipient(@javax.annotation.Nullable OrderIssueContractor recipient) {
    this.recipient = recipient;
  }


  public OrderIssue priceKind(@javax.annotation.Nullable Integer priceKind) {
    this.priceKind = priceKind;
    return this;
  }

  /**
   * Rodzaj ceny dla dokumentu. Odpowiednik pola [rodzajCeny] z importu specjalnego. Pole jest wymagane. [0&#x3D;Niezdefiniowany, 1&#x3D;Brutto, 2&#x3D;Netto]
   * @return priceKind
   */
  @javax.annotation.Nullable
  public Integer getPriceKind() {
    return priceKind;
  }

  public void setPriceKind(@javax.annotation.Nullable Integer priceKind) {
    this.priceKind = priceKind;
  }


  public OrderIssue salePriceType(@javax.annotation.Nullable Integer salePriceType) {
    this.salePriceType = salePriceType;
    return this;
  }

  /**
   * Typ ceny dla dokumentu. Odpowiednik pola [typCeny] z importu specjalnego. Pole jest wymagane. [0&#x3D;Niezdefiniowany, 1&#x3D;Cena A, 2&#x3D;Cena B, 3&#x3D;Cena C, 4&#x3D;Cena D, 16&#x3D;Cena E ... 31&#x3D;Cena T]
   * @return salePriceType
   */
  @javax.annotation.Nullable
  public Integer getSalePriceType() {
    return salePriceType;
  }

  public void setSalePriceType(@javax.annotation.Nullable Integer salePriceType) {
    this.salePriceType = salePriceType;
  }


  public OrderIssue description(@javax.annotation.Nullable String description) {
    this.description = description;
    return this;
  }

  /**
   * Opis dokumentu. Odpowiednik pola [opis] z importu specjalnego.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(@javax.annotation.Nullable String description) {
    this.description = description;
  }


  public OrderIssue positions(@javax.annotation.Nullable List<OrderIssuePosition> positions) {
    this.positions = positions;
    return this;
  }

  public OrderIssue addPositionsItem(OrderIssuePosition positionsItem) {
    if (this.positions == null) {
      this.positions = new ArrayList<>();
    }
    this.positions.add(positionsItem);
    return this;
  }

  /**
   * Get positions
   * @return positions
   */
  @javax.annotation.Nullable
  public List<OrderIssuePosition> getPositions() {
    return positions;
  }

  public void setPositions(@javax.annotation.Nullable List<OrderIssuePosition> positions) {
    this.positions = positions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OrderIssue orderIssue = (OrderIssue) o;
    return Objects.equals(this.typeCode, orderIssue.typeCode) &&
        Objects.equals(this.series, orderIssue.series) &&
        Objects.equals(this.department, orderIssue.department) &&
        Objects.equals(this.paymentRegistry, orderIssue.paymentRegistry) &&
        Objects.equals(this.paymentFormId, orderIssue.paymentFormId) &&
        Objects.equals(this.buyer, orderIssue.buyer) &&
        Objects.equals(this.recipient, orderIssue.recipient) &&
        Objects.equals(this.priceKind, orderIssue.priceKind) &&
        Objects.equals(this.salePriceType, orderIssue.salePriceType) &&
        Objects.equals(this.description, orderIssue.description) &&
        Objects.equals(this.positions, orderIssue.positions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(typeCode, series, department, paymentRegistry, paymentFormId, buyer, recipient, priceKind, salePriceType, description, positions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OrderIssue {\n");
    sb.append("    typeCode: ").append(toIndentedString(typeCode)).append("\n");
    sb.append("    series: ").append(toIndentedString(series)).append("\n");
    sb.append("    department: ").append(toIndentedString(department)).append("\n");
    sb.append("    paymentRegistry: ").append(toIndentedString(paymentRegistry)).append("\n");
    sb.append("    paymentFormId: ").append(toIndentedString(paymentFormId)).append("\n");
    sb.append("    buyer: ").append(toIndentedString(buyer)).append("\n");
    sb.append("    recipient: ").append(toIndentedString(recipient)).append("\n");
    sb.append("    priceKind: ").append(toIndentedString(priceKind)).append("\n");
    sb.append("    salePriceType: ").append(toIndentedString(salePriceType)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    positions: ").append(toIndentedString(positions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("TypeCode", "Series", "Department", "PaymentRegistry", "PaymentFormId", "Buyer", "Recipient", "PriceKind", "SalePriceType", "Description", "Positions"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to OrderIssue
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!OrderIssue.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in OrderIssue is not found in the empty JSON string", OrderIssue.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!OrderIssue.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `OrderIssue` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("TypeCode") != null && !jsonObj.get("TypeCode").isJsonNull()) && !jsonObj.get("TypeCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TypeCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TypeCode").toString()));
      }
      if ((jsonObj.get("Series") != null && !jsonObj.get("Series").isJsonNull()) && !jsonObj.get("Series").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Series` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Series").toString()));
      }
      if ((jsonObj.get("Department") != null && !jsonObj.get("Department").isJsonNull()) && !jsonObj.get("Department").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Department` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Department").toString()));
      }
      // validate the optional field `PaymentRegistry`
      if (jsonObj.get("PaymentRegistry") != null && !jsonObj.get("PaymentRegistry").isJsonNull()) {
        PaymentRegistry.validateJsonElement(jsonObj.get("PaymentRegistry"));
      }
      // validate the optional field `Buyer`
      if (jsonObj.get("Buyer") != null && !jsonObj.get("Buyer").isJsonNull()) {
        OrderIssueContractor.validateJsonElement(jsonObj.get("Buyer"));
      }
      // validate the optional field `Recipient`
      if (jsonObj.get("Recipient") != null && !jsonObj.get("Recipient").isJsonNull()) {
        OrderIssueContractor.validateJsonElement(jsonObj.get("Recipient"));
      }
      if ((jsonObj.get("Description") != null && !jsonObj.get("Description").isJsonNull()) && !jsonObj.get("Description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `Description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("Description").toString()));
      }
      if (jsonObj.get("Positions") != null && !jsonObj.get("Positions").isJsonNull()) {
        JsonArray jsonArraypositions = jsonObj.getAsJsonArray("Positions");
        if (jsonArraypositions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("Positions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `Positions` to be an array in the JSON string but got `%s`", jsonObj.get("Positions").toString()));
          }

          // validate the optional field `Positions` (array)
          for (int i = 0; i < jsonArraypositions.size(); i++) {
            OrderIssuePosition.validateJsonElement(jsonArraypositions.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!OrderIssue.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'OrderIssue' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<OrderIssue> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(OrderIssue.class));

       return (TypeAdapter<T>) new TypeAdapter<OrderIssue>() {
           @Override
           public void write(JsonWriter out, OrderIssue value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public OrderIssue read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of OrderIssue given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of OrderIssue
   * @throws IOException if the JSON string is invalid with respect to OrderIssue
   */
  public static OrderIssue fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, OrderIssue.class);
  }

  /**
   * Convert an instance of OrderIssue to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

